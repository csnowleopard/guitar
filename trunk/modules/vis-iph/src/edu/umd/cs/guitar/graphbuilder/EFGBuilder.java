package edu.umd.cs.guitar.graphbuilder;

import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


import edu.umd.cs.guitar.gen.*;
import edu.umd.cs.guitar.gui.InputException;

import edu.umd.cs.guitar.helper.FileImporter;
import edu.umd.cs.guitar.parser.XMLParser;

/**
 * This class provides methods for accessing EFG which
 * is generated by the GUITAR Ripper
 * 
 * @author Muhammad Ashraf Ishak
 *
 */
public class EFGBuilder {

	
	
	// Mapping: EventID => Event
	private HashMap<String, EventType> eventList = new HashMap<String, EventType>();
	// 
	// Mapping: Row Number => Event
	private HashMap<Integer, EventType> rowEvent = new HashMap<Integer, EventType>();
	
	
	// Mapping: EventID => EventID (one-to-many)
	private HashMap<String, ArrayList<String>> adjacencyList = new HashMap<String, ArrayList<String>>();
	// Mapping: EventID => WidgetID
	private HashMap<String, String> eventWidget = new HashMap<String, String>();
	
	// Mapping: View title => List of Event ID
	private HashMap <String, ArrayList<String>> viewEvents = new HashMap <String, ArrayList<String>>();
	
	private GUIBuilder guiBuilder;
	
	private EFG efg;
	
	private FileImporter fileImporter;
	
	/**
	 * Constructor for GUIBuilder. Needs 2 parameters: the XMLParser and 
	 * the FileImporter
	 * 
	 * @param parser
	 * @param fileImporter
	 * @throws InputException 
	 */
	public EFGBuilder (XMLParser parser, FileImporter fileImporter) throws InputException{
		// Initialize GUIBuilder
		this.guiBuilder = new GUIBuilder(parser);
		this.fileImporter = fileImporter;
		// Populate all events into event list and into the lookup list
		this.efg = parser.getEFG();
		if(efg != null){
			initilizeInfo(efg);
		}else{
			throw new InputException("Error: Unable to process from EFG file!\nThe program will now exit.");
		}
	}
	
	private void initilizeInfo(EFG efg){
		for (int i = 0; i < efg.getEvents().getEvent().size(); i++){
    		EventType event = efg.getEvents().getEvent().get(i);
    		rowEvent.put(i, event);
    		if (!eventList.containsKey(event.getEventId())){
    			eventList.put(event.getEventId(), event);
    		}
    		eventWidget.put(event.getEventId(), event.getWidgetId());
    		String view = this.guiBuilder.getViewTitle(event.getWidgetId());
    		if (viewEvents.get(view) == null){
    			viewEvents.put(view, new ArrayList<String>());
    		}
    		if (!viewEvents.get(view).contains(event.getEventId())){
    			viewEvents.get(view).add(event.getEventId());
    		}
    	}
    	
    	// Populate adjacency list based on rows from EFG
    	for (int i = 0; i < efg.getEventGraph().getRow().size(); i++){
    		RowType row = efg.getEventGraph().getRow().get(i);
    		for (int j = 0; j < row.getE().size(); j++){
    			if (row.getE().get(j) > 0){
    				String curr = rowEvent.get(i).getEventId();
    				if (adjacencyList.get(curr) == null){
    					adjacencyList.put(curr, new ArrayList<String>());
    				}
    				ArrayList<String> t = adjacencyList.get(curr);
    				t.add(rowEvent.get(j).getEventId());
    				adjacencyList.put(curr,t);
    			}
    		}
    	}
	}
	
	/**
	 * Get all mapping of {View/Window ID ==> Screenshots}
	 * @return
	 */
	public HashMap<String, BufferedImage> getAllImagesByView (){
		HashMap <String, BufferedImage> result = new HashMap <String, BufferedImage>();
		if (fileImporter.screenShots == null){
			System.out.println("File not found!");
		} else {
			for (String view: getViewList()){
				for (String imageName: fileImporter.nameImage.keySet()){
					// View(window) ==> image naming convention:
						// N is an integer where,
						// Window N ==> imgNNN.jpg (for image name, N is padded with 3 zeros on the left)
					// Now we need to extract the number
					Pattern p = Pattern.compile("img(\\d\\d\\d).(.*)");
					Matcher m = p.matcher(imageName);
					int numImg = 0;
					while (m.find()){
						numImg = Integer.parseInt(m.group(1));
					}
					p = Pattern.compile("Window\\s(.*)");
					m = p.matcher(view);
					int numView = 0;
					while (m.find()){
						numView = Integer.parseInt(m.group(1));
					}
					if (numView == numImg){
						//System.out.println(view +" ==> "+imageName);
						result.put(view, fileImporter.nameImage.get(imageName));
					}
				}
			}
		}
		return result;
	}
	
	/**
	 * Get a screenshot by its associated window/view ID
	 * @param view
	 * @return
	 */
	public BufferedImage getImageByView (String view){
		HashMap <String, BufferedImage> r = getAllImagesByView();
		for (String v: r.keySet()){
			if (view.equals(v)){
				return r.get(v);
			}
		}
		return null;
	}
	
	/**
	 * Get list of all View title
	 * @return
	 */
	public ArrayList<String> getViewList (){
		ArrayList<String> result = new ArrayList<String>();
		for (String view: viewEvents.keySet()){
			if (!result.contains(view)){
				result.add(view);
			}
		}
		return result;
	}
	
	/**
	 * Get list of EventType associated with a View
	 * @param viewTitle
	 * @return
	 */
	public ArrayList<EventType> getEventsByView (String viewTitle){
		ArrayList<EventType> result = new ArrayList<EventType>();
		for (String view: viewEvents.keySet()){
			if (view.equals(viewTitle)){
				for (String eventID: viewEvents.get(view)){
					EventType e = this.eventList.get(eventID);
					if (!result.contains(e)){
						result.add(e);
					}
				}
			}
		}
		return result;
	}
	
	/**
	 * Get View title of an Event
	 * @param eventID
	 * @return
	 */
	public String getViewByEvent (String eventID){
		for (String v: viewEvents.keySet()){
			for (String e: viewEvents.get(v)){
				if (e.equals(eventID)){
					return v;
				}
			}
		}
		return null;
	}
	
	
	/**
	 * Get mapping of all views with its related Event ID
	 * @return
	 */
	public HashMap <String, ArrayList<String>> getViewEvents() {
		return viewEvents;
	}
	
	/**
	 * Retrieve a widget which associated with an event (one-to-one relation)
	 * @param eventID
	 * @return Widget associated with event
	 */
	public ComponentType getWidgetFromEvent (String eventID){
		return this.guiBuilder.getWidgetList().get
			  (this.getEventList().get(eventID).getWidgetId());
	}
	
	
	
	/**
	 * Retrieve event from event list
	 * @param eventID
	 * @return Event associated with its eventID
	 */
	public EventType getEvent(String eventID){
		return this.eventList.get(eventID);
	}
	
	
	/**
	 * Retrieve list of other events connected with an event
	 * @param eventID
	 * @return
	 */
	public ArrayList<EventType> getEventFromEdges (String eventID){
		ArrayList<String> ids = this.getAdjacencyList().get(eventID);
		ArrayList<EventType> result = new ArrayList <EventType>();
		for (String a: ids){
			result.add(this.eventList.get(a));
		}
		return result;
	}

	public void setAdjacencyList(HashMap<String, ArrayList<String>> adjacencyList) {
		this.adjacencyList = adjacencyList;
	}

	public HashMap<String, ArrayList<String>> getAdjacencyList() {
		return adjacencyList;
	}

	
	public void setEventWidget(HashMap<String, String> eventWidget) {
		this.eventWidget = eventWidget;
	}

	public HashMap<String, String> getEventWidget() {
		return eventWidget;
	}

	public HashMap<String, EventType> getEventList(){
		return this.eventList;
	}
	public void setEventList(HashMap<String, EventType> eventList) {
		this.eventList = eventList;
	}

	public void setGuiBuilder(GUIBuilder guiBuilder) {
		this.guiBuilder = guiBuilder;
	}

	public GUIBuilder getGuiBuilder() {
		return guiBuilder;
	}
	
	public void setEfg(EFG efg){
		this.efg = efg;
	}
	
	public EFG getEfg(){
		return efg;
	}

	public void setViewEvents(HashMap <String, ArrayList<String>> viewEvents) {
		this.viewEvents = viewEvents;
	}
	
}
